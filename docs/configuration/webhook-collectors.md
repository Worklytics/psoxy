# Webhook Collectors



**Use cases:**
- custom tools, managed in-house by customers. Customers can fire webhooks from these tools to webhook collectors, which sanitize the data (namely, consistently pseudonymizing any PII such that it's linkable to other data sources) and collect it into bulk data storage (e.g. S3, GCS, etc), from which it can later be transferred to Worklytics (asynchronously) for analysis.
- on-prem / self-hosted tools (JIRA) that can be configured to fire webhooks
- tools that fire webhooks which provide richer data than they expose via their APIs
- an "API" to which scripts / export processes can send (POST) historical data over HTTP, rather than using Bulk Data Mode (which would require them to deal with aggregating data into files for efficiency; as well as directly interacting with s3/gcs)

## Concept
- **Tool Client** - Javascript or web application client, running in a user endpoint (browser, mobile, etc), that sends webhook payloads directly to the collector (in principle)
- **Tool Server** - the backend server of the tool.
- **Webhook Collector** - the instance of Psoxy that collects webhooks from the Tool Client or Tool Server, and sanitizes the data before storing it in bulk storage (e.g. S3, GCS, etc).

## Authentication

Authentication is required to ensure *integrity* of the data collected; specifically attribution of webhook to a specific *actor* (user) can be trusted for analysis purposes. This is done by each webhook request including a signature token that can be verified by the collector. The signature token will be an JWT identity token generated by the Tool Server and securely distributed to the Tool Client. It should be held by the Tool Client as a secret, equivalent to a session token/cookie.

The Tool Client will include this token in the webhook payload, and the Webhook Collector will verify it before accepting the payload.

See [jwt.io](https://jwt.io/) for more details on how to generate and verify JWT tokens in general.

`REQUIRE_AUTHORIZATION_HEADER` - env var that indicates whether the Webhook Collector requires an `Authorization` header to be sent. This header MUST be a valid JWT identity token, signed with one of the public keys configured in `ACCEPTED_AUTH_KEYS`.

It MUST contain:
  - `typ` (type) claim, which indicates the type of the token. This should be `JWT`.
  - `alg` (algorithm) claim, which indicates the algorithm used to sign the token. This should be `RS256`.
  - `aud` (audience) claim, which indicates the audience for which the token is intended. This should be the collector endpoint URL, eg `https://jr2e4x60sa.execute-api.us-east-1.amazonaws.com/webhook_collectors/llm-portal`.
  - `iss` (issuer) claim, which indicates the issuer of the token. This should ALSO be the collector endpoint URL.
  - `iat` (issued at) claim, which indicates when the token was issued, in seconds since the epoch. Must not be in the future.
  - `exp` (expiration) claim, which indicates when the token expires, in seconds since the epoch. Must not be more than 365 days in the future.
  - `kid` (key ID) claim, which indicates the key that was used to sign the token. This should match one of the keys in `ACCEPTED_AUTH_KEYS`.

It MAY contain:
  - `sub` (subject) claim, which indicates the user or entity that the token represents. (eg, user using the tool)
  - additional claims that the Tool Server may want to include, with, as of 0.5.3, no restrictions on semantics of those.

All of the above claims have their standard semantics per OpenID Connect and JWT specifications.

`ACCEPTED_AUTH_KEYS` - env var that references all the public keys that will be tested against the JWT identity token. if JWT received is valid according to any of them, then the request is authenticated and authorized. Options:
   - `aws-kms:arn:aws:kms:REGION:ACCOUNT_ID:alias/ALIAS_NAME`
   - `base64:BASE64_ENCODED_PUBLIC_KEY` - must be RSA public key in base64 format
   - `gcp-kms:projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{key}/cryptoKeyVersions/{version}`

This is POTENTIALLY a CSV, if multiple keys are concurrently valid (due to rotation/migration).

In both AWS/GCP case, asymmetric key pairs CANNOT be automatically rotated, so we expect multiple keys to be configured in the usual case. For simplicity, if you're using our Terraform modules to manage keys and rotation, we'll provision TWO keys scheduled to expire after N and N/2 days, respectively. You should encrypt payloads with the key that expires FURTHEST in the future (refer to the ISO-formatted timestamp in the tag `rotation_time` to determine this). You should run `terraform apply` at least every N/2 days to ensure that the keys are rotated and the new key is provisioned.

Our module will also create a KMS key alias ending in `_signing-key`; any app you use to create auth tokens should use this alias when signing. If rotation is enabled, this alias will be updated accordingly on every `terraform apply` to point to the correct key.  Eg, if your environment id is `worklytics`, and your proxy webhook collection id is `llm-portal`, then alias will be `worklytics/llm-portal_signing-key`.

Alternatively, you may manage the keys yourself and pass in kms key aliases via the `auth_keys` property of the `webhook_collectors` variable.  Have `current` and `previous` aliases point to the current and previous keys, respectively. When you rotate, update these (previous --> current, then current to your new key). Ensure you're ALWAYS signing the auth tokens with the `current` key.

Note that this scheme **enables authentication of the request** AND **partial integrity verification of the request/payload**. Eg, a valid signed JWT identity token ensures that it originated with a trusted client. If you control to whom you issue auth tokens, you can trust these as authenticated requests. Additionally, the webhook rules may validate the request/payload's integrity for a subset of fields against the JWT claims included in the token; since these claims were signed by your private key, you can trust that the fields you checked are authentic.  However, any unchecked fields in the payload/query string may have been forged either by the client itself OR by a malicious actor who somehow obtained the JWT identity token.  This design choice is intended to optimize for performance and avoid many round-trips to a trusted server to generate JWT identity tokens. The usual scenario is that your server issues JWT token for each client session; clients send that token directly to webhook collection endpoint with each payload; the webhook collector is able to authenticate the request and verify the integrity of the identity of the user/client.  While users/clients may be able forge aspects of the payload, they will not be able to forge the identity of sender of the payload.

`ALLOW_ORIGINS` environment variable can be used to control what origins are allowed to send webhooks to the collection; defaults to `*`, which is all. This is aligned to CORS standard.

`AUTH_ISSUER` environment variable for expected issuer of the JWT identity token. This is used to verify the `iss` claim in the JWT identity token.

`WEBHOOK_OUTPUT` - an env var that directs webhooks recieved by this collector should be sent; typically a queueing service (eg, SQS, PubSub, Cloud Tasks) to *batch* processing.

`WEBHOOK_BATCH_OUTPUT` - the env var that controls where final output of the batched webhooks is sent; typically a cloud storage bucket (eg, S3, GCS). This output would be expected to be NDJSON files, gzipped.


The webhook collector instance itself provides OIDC endpoints:
  - `/.well-known/openid-configuration` - standard return of OIDC configuration, including `issuer` and `jwks_uri`; see [OpenID Connect Discovery 1.0](https://openid.net/specs/openid-connect-discovery-1_0.html)
  - `/.well-known/jwks.json` - public keys for the auth key pairs that collector will accept as JWTs. see [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html)

### AWS KMS Keys + NodeJS Example
As an example, if you're using AWS KMS keys to sign the JWT identity tokens (the default using our Terraform modules) and have a server (backend) for your Tool in NodeJS, you might create a JWT identity token as follows:

```javascript
import {KMSClient, SignCommand} from '@aws-sdk/client-kms';
import crypto from 'node:crypto';

let claims = {
      iss: 'https://jr2e4x60sa.execute-api.us-east-1.amazonaws.com/webhook_collectors/llm-portal', // the collector endpoint URL
      sub: 'alice@worklytics.co', // the user who is authenticated by the Tool Server for the Tool Client
      aud: 'https://jr2e4x60sa.execute-api.us-east-1.amazonaws.com/webhook_collectors/llm-portal', // the collector endpoint URL
      iat: Math.floor(Date.now() / 1000), // current time in seconds
      exp: Math.floor(Date.now() / 1000) + 60 * 60, // 1 hour from now; could be more;
    }


function base64url(input) {
    return input.toString('base64')
        .replace(/=/g, '')
        .replace(/\+/g, '-')
        .replace(/\//g, '_');
}

/**
 * @param {object} claims - the usual JWT ones, iss, sub, etc. will be stringified
 * @param {string} keyArn
 * @param {Credentials} credentials
 * @param {string} region
 * @returns {Promise<string>}
 */
async function signJwtWithKMS(claims, keyArn, credentials, region) {
    const client = new KMSClient({
        region: region,
        credentials: credentials,
    });

    const encodedHeader = base64url(Buffer.from(JSON.stringify({
        "alg": "RS256",
        "kid": keyArn,
        "typ": "JWT",
    })));
    const encodedPayload = base64url(Buffer.from(JSON.stringify(claims)));
    const signingInput = `${encodedHeader}.${encodedPayload}`;

    const hash = crypto.createHash('sha256').update(signingInput).digest();

    const command = new SignCommand({
        KeyId: keyArn,
        SigningAlgorithm: 'RSASSA_PKCS1_V1_5_SHA_256',
        Message: hash,
        MessageType: 'DIGEST'
    });

    const response = await client.send(command);

    const signature = base64url(Buffer.from(response.Signature));
    return `${signingInput}.${signature}`;
}

let signingKeyArn = 'arn:aws:kms:us-east-1:123456789012:key/your-key-id'; // if using our Terraform module, you can use an alias `llm-portal_signing-key`

let credentials = { }; // credentials for your AWS principal of your server, eg from AWS SDK or environment variables

// this signature should be kept secret and securely distributed to the Tool Client; anyone in possession of it can impersonate the user
// for the purposes of webhook data collection
let signature = await signJwtWithKMS(claims, signingKeyArn, credentials, 'us-east-1');
```

You would then pass the resulting token to the Tool Client, to send with every webhook request to the Webhook Collector as the `Authorization` header.

## Proxy Instance in Terraform

If you forked on of our example repos after ~0.5.3, you should be able to add something like the following to your `terraform.tfvars`:

```hcl
webhook_collectors = {
  "llm-portal" = {
    rules_file = "work-events.yaml"
    provision_auth_key = {
      rotation_days = 2
    }
    example_identity     = "erik@worklytics.co"
    example_payload_file = "work-events-example.json"
  }
}
```

Where `work-events.yaml` is YAML-encoded rules, such as:

```yaml
endpoints:
  - jwtClaimsToVerify:
      sub:
        payloadContents:
          - "$.actor.id"
    transforms:
      - !<pseudonymize>
        jsonPaths:
          - "$.actor.id"
        encoding: "URL_SAFE_TOKEN"
```

The above example ensures that the `id` property of the `actor` property sent as the body of the POST request to the endpoint MUST match the `sub` claim in the JWT sent as the `Authorization` header with the request.  Additionally, a pseudonymize transform will be applied to the any fields in the payload matching the JSON path `$.actor.id` (eg, that same field).

See the java class `WebhookCollectionRules` for details on supported elements of the YAML. But briefly:
- `endpoints` - a list of `endpoint`
- endpoint properties:
  - `jwtClaimsToVerify` - map of field in JWT claims to spec on what to verify it against in the payload contents
  - `transforms` - list of transforms to apply; everything supported for [API Data Sanitization case](./api-data-sanitization.md) 
- `jwtClaimsToVerify` spec properties:
  - `queryParam` - name of a parameter in the query string of the POST sent to the endpoint
  - `payloadContents` - a list of JSON paths relative to payload root to evaluate; any matching value in the payload MUST be the same as the field in the JWT claims.

## Data Flows

### Scenario A : Tool Client to Webhook Collector

  1. Tool Server generates a JWT identity token for the user, which is securely distributed to the Tool Client.
  2. Tool Client includes the JWT identity token in the webhook payload, sent directly to the Webhook Collector.

This is analogous to how many metric systems, such as Google Analytics, work. Some minimal server-side logic is required to obtain the JWT identity token and distribute it to the Tool Client.

### Scenario B : Tool Server to Webhook Collector

Tool Client does NOT communicate directly with the Webhook Collector. Instead, the Tool Server sends webhook payloads to the Webhook Collector

This requires more extensive server-side logic in the Tool Server; and may have more performance implications.

### Scenario C : Tool Client to Webhook Collector without Identity Verification

In this scenario, the Tool Client sends webhook payloads directly to the Webhook Collector, which is configured to NOT require a JWT identity token.  This is useful when Webhook Collector can be hosted on a trusted network, or its trust in the Tool Client can be independently established (such as with IAM/API Gateway rules in AWS
